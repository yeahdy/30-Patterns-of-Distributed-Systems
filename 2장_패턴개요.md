## 1. TCP/IP 비동기 통신 이해와 분산 시스템

TCP/IP 통신은 겉으로 보기에 **동기 요청-응답**처럼 느껴지지만, 내부 동작은비동기(Asynchronous)로 처리됩니다.
클라이언트의 요청은 네트워크 큐나 버퍼에 저장되어 순차적으로 비동기 처리됩니다. 즉, 요청을 보냈다고 해서 서버가 즉시 결과를 반환하는 것이 아님.

* TCP : 패킷이 순서대로 도착하고 손실 없이 보장
* TCP 예제
  * HTTP/HTTPS (Spring REST API) : 데이터 정확성 중요
  * DB 연결 (Oracle, Aurora) : 트랜잭션/쿼리 무결성
  * Kafka Producer/Consumer (기본 설정 시) : 메시지 순서/재전송 보장
  * Redis (기본 TCP) : 키/값 정확성

</br>

## 2. 리더 선출 조건

분산 합의 알고리즘 (Raft 등)에서 리더가 교체될 때 가장 중요한 원칙은 **데이터 유실 방지*

* **리더 후보 조건:** **가장 최신 로그를 가진 노드**만이 새로운 리더의 후보됨.
* **데이터 유실 방지:** 만약 뒤처진 로그를 가진 노드가 리더가 되면, 그 노드가 **가지고 있지 않은** 이전 리더의 커밋된 데이터가 유실되는 치명적인 상황이 발생.
* **예시 (3노드):**
    * **Neptune (前 리더):** 최신 로그 $\rightarrow$ **후보 가능**
    * **Saturn (Follower):** 최신 로그와 동기화됨 $\rightarrow$ **후보 가능**
    * **Jupiter (Follower):** 복제에 뒤처져 로그가 누락됨 $\rightarrow$ **후보 불가 (❌)**

</br>

## 3. 과반수 정족수(Quorum)

**결정을 내릴 수 있는 최소한의 동의(ACK)를 얻은 노드 수**를 의미.

* **역할:** 로그 커밋 (Commit), 쓰기 승인 (Write ACK), 리더 선출 등 모든 분산 결정에 필수적입니다.
* **계산:** 노드 $N$개 중 $\lceil (N/2) \rceil$ 개 이상의 노드 동의가 필요합니다.
    * 예: **3노드** 환경에서 **과반수는 2**입니다. (2/3)
    * 예: **6노드** 환경에서 **과반수는 4**입니다. (4/6)
* **시스템 안전성:** 과반수를 확보하지 못하면 시스템은 **쓰기(Write)를 중단**하여 데이터 일관성 파괴를 방지합니다. 읽기는 조건부로 가능할 수 있습니다.

</br>

### 3-1. "매 요청마다 과반수 정족수를 확인하는건가?" 

원칙적으로 **모든 Write 요청**은 **로그 복제 $\rightarrow$ 과반수 ACK $\rightarrow$ Commit** 과정을 거친다.

* **성능 최적화:** 매 요청마다 네트워크 왕복(RTT)이 발생하면 성능이 저하되므로 다음과 같은 기법으로 최적화가 가능합니다.
    * **배치 처리 (Batching):** 여러 Write 요청을 하나로 묶어 동시에 처리합니다. 한 번에 ACK/Commit 과정을 수행하여 네트워크 오버헤드를 줄입니다.
    * **파이프라인 (Pipelining):** ACK를 기다리지 않고 다음 요청을 바로 전송합니다.
    * **백그라운드 Catch-up:** 팔로워가 일시적으로 느린 경우, 데이터 유실 없이 나중에 따라잡도록 허용합니다.

> * **이벤트 버스트 트래픽:** 주문 이벤트가 순간적으로 몰릴 때, Kafka Producer는 메시지를 배치로 묶어 전송하여 ACK 횟수를 줄입니다.

</br>

### 3-2. 리더/팔로워 & 장애 상황 시 쓰기 중단

분산 시스템의 **안전성(Safety)** 보장을 위해, 단순 과반수 이상의 노드가 동작해야 쓰기가 가능합니다.

* **사례:** 전체 3개의 노드 (Leader A, Follower B, Follower C) 중 **B와 C 모두 장애** 발생.
* **결과:** 리더 A만 살아있으므로 과반수 (2/3)를 충족하지 못합니다. $\rightarrow$ **쓰기(Write) 중단**
* **이유:** 시스템이 쓰기를 허용할 경우, 네트워크 분할(Partition) 상황에서 **Split Brain (리더가 2명 이상 생기는 현상)**이 발생하여 **데이터 일관성(Data Consistency)**이 깨지는 것을 방지하기 위함입니다.
    * **읽기(Read)는 조건부로 가능**할 수 있지만, 데이터의 신뢰성(Freshness)을 보장할 수 없습니다.

</br>

## 4. 분산 로그 복제 (Replication) 과정

분산 시스템에서 데이터를 안전하게 '쓰기(Write)' 위한 표준적인 과정은 **'로그 복제'** 기반으로 이루어집니다.

| 단계 | 설명 | 역할 노드 |
| :--- | :--- | :--- |
| **1. 요청** | 클라이언트가 쓰기 요청을 **리더(Leader)** 노드에 전송합니다. | Leader |
| **2. 복제** | 리더는 해당 쓰기 요청(로그)을 복제 요청으로 **팔로워(Follower)** 노드들에게 전송합니다. | Leader $\rightarrow$ Follower |
| **3. 승인 (ACK)** | 팔로워는 로그를 로컬 저장소에 안전하게 저장한 후, **ACK (Acknowledgement)** 응답을 리더에게 보냅니다. | Follower |
| **4. 커밋 결정** | 리더는 과반수의 팔로워로부터 ACK를 받으면, 해당 로그를 **Commit** 처리합니다. (안전 확정) | Leader |
| **5. 커밋 전파** | 리더는 해당 로그의 **Commit 여부**를 팔로워들에게 전달합니다. | Leader $\rightarrow$ Follower |
| **6. 완료** | 팔로워들도 전달받은 정보를 바탕으로 해당 로그를 Commit 완료합니다. | Follower 

* **핵심:** 과반수의 노드가 승인하기 전까지 로그는 언커밋 상태(Uncommitted)이며, 장애 발생 시 롤백될 수 있습니다.

### 4-1. ACK와 로그 커밋 시점의 관계

| 용어 | 역할 및 시점 |
| :--- | :--- |
| **ACK (Acknowledgement)** | 팔로워가 리더에게 "로그를 로컬에 안전하게 저장했습니다"라고 응답하는 시점. |
| **Commit 결정** | 리더가 **과반수 ACK**를 받은 시점. 이 순간 로그는 **High Watermark**가 업데이트되며 안전하게 확정됩니다. |
| **Commit 적용** | 팔로워가 리더로부터 Commit 결정 통보를 받고 자신의 로그를 **실제 Commit** 처리하는 시점. |

### 4-2. Kafka Producer의 ACK 모드

Kafka에서는 **Producer**가 메시지를 전송할 때, 데이터의 안정성을 조정하기 위해 세 가지 `acks` 레벨을 제공.
금융/결제 등 데이터 유실이 치명적인 환경이나 트래픽이 높은 서비스에서는 `acks=all`을 기본 설정으로 권장.

| `acks` Level | 의미 | 안정성 | 성능 |
| :--- | :--- | :--- | :--- |
| `acks=0` | 리더의 응답을 기다리지 않음. 전송 즉시 성공 처리. | **가장 낮음** (데이터 유실 가능성 높음) | **가장 빠름** |
| `acks=1` | **리더**만 메시지를 받고 응답하면 성공 처리. | 중간 (리더 장애 시 유실 가능) | 빠름 |
| `acks=all` | **ISR(In-Sync Replicas)의 과반수**가 응답해야 성공 처리. | **가장 높음** (일반적으로 가장 안전) | 느림 (안정성 보장) |

</br>

## 5. Raft 알고리즘

**Raft**는 분산 시스템의 노드 간 **상태 일관성**을 유지하기 위한 대표적인 **분산 합의 알고리즘**입니다.

* **주요 기능:** **리더 선출 (Leader Election)**, **로그 복제 (Log Replication)**, **안전성 (Safety)** 보장.
* **쓰기 승인 조건:** Raft 역시 **과반수(Majority)** 노드의 승인을 요구합니다.
* **리더의 자격:** **가장 최신성(Up-to-date) 있는 로그**를 가진 노드가 새로운 리더가 될 수 있습니다.
* **내고장성:** 네트워크 일부 장애나 노드 다운이 발생해도, **과반수 노드만 살아있다면** 시스템은 계속 정상적으로 동작할 수 있습니다.
   * **Raft vs. Kafka:** 기존 Kafka는 로그 복제에 **ISR 기반 메커니즘**을 사용했습니다. 하지만 최신 Kafka 버전(KRaft)에서는 **메타데이터 관리**에 Raft 알고리즘을 도입하여 의존성을 줄이고 안정성을 높였습니다.

</br>

## 6. High Watermark (HWM)

**과반수**의 팔로워로부터 ACK를 받은 로그 중 안전하게 커밋이 완료된 로그의 위치(가장 높은 인덱스)

* **작동:** 리더가 과반수 ACK를 확인하는 순간 HWM을 업데이트합니다.
* **중요성:** HWM을 팔로워들에게 알려줌으로써 팔로워들도 **어디까지 commit 되었는지**를 알고 자신의 로그를 commit 처리합니다.
* **소비자(Consumer) 안전:** Kafka에서 소비자는 **HWM 이하**의 메시지만 소비할 수 있어, 아직 commit 되지 않은 (유실될 수 있는) 메시지를 읽는 것을 방지합니다.

</br>

## 7. Heartbeat (하트비트)

노드가 '나 살아있다'라는 생존 신호를 주기적으로 전송하는 메커니즘입니다.

* **목적:** 노드의 생존 여부(Liveness)를 확인하고, 리더가 다운되었을 경우 신속하게 감지하여 새로운 리더를 선출하는 데 사용됩니다.
* **로그 복제와의 관계:** 하트비트는 **데이터 복제 요청과 별개**로 동작하는 것이 주된 역할입니다.
    * *(다만, 최적화를 위해 하트비트 메시지에 **Commit Index**를 함께 실어 보내는 경우도 있어 로그 복제 역할과 섞여 헷갈리기도 합니다.)*

---

🎯 **핵심 문장/용어 정리**

| 개념 | 핵심 설명 |
| :--- | :--- |
| **과반수 정족수(Quorum)** |  **리더 선출을 위해 과반수**. 쓰기/Commit을 판단하는 **최소 동의** 기준입니다. |
| **ACK** | 팔로워가 리더에게 보내는 로그 저장 완료 응답. **Commit 판단의 기준**이 됩니다. |
| **Raft** | **분산 합의 알고리즘**의 표준. 리더 선출, 과반수 Commit을 담당합니다. |
| ***High Watermark(HWM)** | ***과반수 승인 후 안전하게 commit이 완료된** 메시지의 마지막 위치로 소비자가 읽을 수 있는 경계. (Commit Index 항상 포함) |
| **Heartbeat** | 리더가 노드들에게 주기적으로 보내는 **생존 체크 신호** (Commit Index 포함 가능) |
| **Leader 최신 로그** | **새 리더가 될 수 있는 필수 조건**. 데이터 유실을 방지합니다. |

